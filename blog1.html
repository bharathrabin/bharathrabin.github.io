<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Turing Machines</title>
	<link rel="stylesheet"  href="https://fonts.googleapis.com/css?family=Roboto:400,400i,500,500i,700,700i,900,900i">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="styles/reset.css">
	<link rel="stylesheet" href="styles/-debug.css">
	<link rel="stylesheet" href="styles/article.css">
	<link rel="stylesheet" href="styles/article-image.css">

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
	<article id="The-beginning">
		<h1><a href="#The-beginning">Basic Intuitions in Theoretical CS</a></h1>
		<h2><em>Topics:</em>Languages/Decision Problems</h2>
		<time datetime="04-08-2021">Apr. 8, 2021</time>
		<h3>Our Journey</h3>
		<p><em>"The Turing machine is a simple embodiment of the age-old intuition that computation consists of applying mechanical rules to manipulate numbers, where the person/machine doing the manipulation is allowed a scratch pad on which to write the intermediate results. " - Arora, Barak (2007)</em></p>
		<p>Since this is my first technical post I thought I would start at the beginning. For us, computer science begins with Alan Turing. Whilst, there were a lot of people prior to Turing who contributed a great deal to the development of modern day computer science, Turing's theoretical construction, what we call a Turing Machine allowed us to rigorously define a computing machine.</p>
		<p><strong>So what does this machine take as an input ?</strong> -  For now, we assume that the input into this computing machine is a string of bits.</p>
		<p><strong>So what does this machine give as an output?</strong> -  We also assume that the output of this machine is also a string of bits.</p>
		<p>The set of all binary strings of length <em>n</em> is denoted by \(\{0, 1\}^n\) and the set of binary strings is denoted by \(\{0, 1\}^* = \cup_{n\geq0} \{0, 1\}^n\)</p> 
		<p>Most objects can be represented as binary strings using simple encodings. (For e.g. the integer 33 can be written as 100001 using the standard binary expansion formula). Complicated objects such as graphs i.e a tuple of sets \((V, E)\) where \(V\) denotes the vertex set and \(E\) denotes the edge set can be represented as an \(n×n\) matrix \(M\) such that $$     M = (m)_{i, j} = \begin{cases}
        1, & \text{iff } (i, j) \in E\\
        0, & \text{else }\\
        \end{cases}$$
    	The matrix M can be passed to a Turing machine as a vector after flattening. We assume from hereon that any input to a Turing machine has already been binarized.</p>
    	<p><strong>Note:</strong> That for a natural number \(z\) the binary expansion \(bin(z)\) requires \(O(lgn)\) bits. \(lg\) denotes the logarithm to the base 2.</p>
    	<p>A special case of the family/set of functions $$\{f| f: \{0, 1\}^* \mapsto \{0, 1\}^* \}$$ is the family of functions $$ G = \{f | f:\{0, 1\}^* \mapsto \{0, 1\}\}$$ Note that the functions in the family G are functions that map a binary string to either 0 or 1. The set \(G\) is referred to as the set of decision problems. This naming is appropriate as for any function \(f \in G\) upon an input \(x\), \(f(x)\) outputs either a 1 interpreted as "yes" or outputs a 0 interpreted as "no".</p>
    	<p>We also identify a function \(f \in G\) with the set of inputs that upon input to \(f\), output a 1 i.e. $$L_f := \{x : f(x) = 1\}$$
    	We call \(L_f\) a language or a decision problem.</p>. 
	</article>

</body>
</html>